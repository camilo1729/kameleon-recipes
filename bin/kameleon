#!/usr/bin/env ruby
#    Kameleon: a tool to build virtual machines or livecd images

require 'yaml'
require 'fileutils'
require 'optparse'
require 'erb'
require 'session'
require 'tempfile'
require 'pp'

# History file
$histfile="#{ENV['HOME']}/.kameleon_history"
$history=[]

# Cleaning script
$clean_script=`mktemp`
$clean_script.strip!

############################
### function definitions ###
############################


def func_test
  1 + 1
end


### Hash that keeps elements in the insertion order -- it's more
### convenient for storing macrostep->microstep->comand structure
class OrderedHash < Hash
  def initialize
    @key_list = []
    super
  end
  def []=(key, value)
    if has_key?(key)
      super(key, value)
    else
      @key_list.push(key)
      super(key, value)
    end
  end

  def by_index(index)
    self[@key_list[index]]
  end

  def each
    @key_list.each do |key|
      yield( [key, self[key]] )
    end
  end

  def delete(key)
    @key_list = @key_list.delete_if { |x| x == key }
    super(key)
  end
end

### helper functions for output colorizing
def colorize(text, color_code)
  "#{color_code}#{text}\e[0m"
end

def red(text); colorize(text, "\e[31m\e[1m"); end
def green(text); colorize(text, "\e[32m\e[1m"); end
def blue(text); colorize(text, "\e[34m\e[1m"); end
def cyan(text); colorize(text, "\e[36m"); end

### verifies if the command has to be cached
$cacheable_cmds=[/.*apt-get .* install .*/,/\.*wget \.*/,/\.*git \.*/,]
## This will be used for caching version control systems that cannot be cached
## using the proxy approach.
## Additionally for putting all the scripts used into the cache.
def cmd_cache?(cmd_value,step)

  return nil if cmd_value.nil?
  open("#{$workdir}/cache_file",'a') do |cache_file|
    $cacheable_cmds.each{ |c_cmd|
      cache_file.puts "#{step}: #{cmd_value}" if cmd_value.match c_cmd
    }
    ### the lines below are for keeping track of the scripts used and put them into the cache.
    executable = cmd_value.split(" ")[0]
    ## Fix-me  it's a dirty way of doing it
    path = `which #{executable}`
    if $?.exitstatus == 0
      final_cmd="file `which #{executable}`"
      output = IO.popen(final_cmd)
      if output.readline["text executable"]
        cache_file.puts "#{step}: #{path.chop}"
        ### Generation of the command used for cache it
        cmd_for_cache = "cp #{path.chop} $$cache_dir/#{step}/data/"
        ### redirecting the script in the step file
        new_executable = "$$cache_dir/#{step}/data/#{File.basename(executable)}"
        return cmd_for_cache, executable, new_executable
      end
    end

  end
  return nil
end


def make_exec_chroot( cmd )
  "chroot,chroot " + $chroot + " bash -c \"" + cmd +"\""
end

def make_exec_appliance( cmd )
  "cd " + $chroot + "; " + cmd
end

def make_exec_current( cmd )
  "cd " + $current_dir + "; " + cmd
end

### function for converting command definitions into bash commands
def cmd_parse(cmd,step)
  if cmd.keys[0]=="check_cmd"
    #TODO check if the command exists before starting the script
    make_exec_current( "which " + cmd.values[0] + " >/dev/null" )
  elsif cmd.keys[0]=="check_cmd_chroot"
    make_exec_chroot( " which " + cmd.values[0] )
  elsif cmd.keys[0]=="exec_current"
    make_exec_current( cmd.values[0] )
  elsif cmd.keys[0]=="exec_appliance"
    make_exec_appliance( cmd.values[0] )
  elsif cmd.keys[0]=="exec_chroot"
    make_exec_chroot( cmd.values[0] )
  elsif cmd.keys[0]=="append_file"
    return "echo \"" + cmd.values[0][1] + "\" >> " + $chroot + "/" + cmd.values[0][0]
  elsif cmd.keys[0]=="write_file"
    return "echo \"" + cmd.values[0][1] + "\" > " + $chroot + "/" + cmd.values[0][0]
  elsif cmd.keys[0]=="erb_config"
    return "ERB-config,#{cmd.values[0][0]},#{cmd.values[0][1]}"
  elsif cmd.keys[0]=="breakpoint"
    return "KML-breakpoint " + cmd.values[0]
  elsif cmd.keys[0]=="exec_ctxt" || cmd.keys[0]=="exec_context"
    return context_parse(cmd.values[0])
  elsif cmd.keys[0]=="exec_on_clean"
    return "Clean-command,#{cmd.values[0]}"
  elsif cmd.keys[0]=="on_clean"
    output=[]
    cmd.values.each do |clean_entry|
      clean_entry.each do |entry|
        entry.each do |clean_cmd,val|
          if clean_cmd == "exec_current"

          elsif clean_cmd == "exec_appliance"
            output << "echo \"" + "cd " + $chroot + "; " + val + "\" > " + $clean_script + ".rev; cat " + $clean_script + ">> " + $clean_script + ".rev; mv -f " + $clean_script + ".rev " + $clean_script
          elsif clean_cmd == "exec_chroot"
            output << "echo \"" + "chroot " + $chroot + " " + val + "\" > " + $clean_script + ".rev; cat " + $clean_script + ">> " + $clean_script + ".rev; mv -f " + $clean_script + ".rev " + $clean_script
          else
            printf("Step %s: no such on_clean command: %s\n", step, clean_cmd)
            exit(9)
          end
        end
      end
    end
    return output.join(';')
  else
    printf("Step %s: no such command %s\n", step, cmd.keys[0])
    exit(9)
  end
end

# Global variables parsing
def var_parse(str, path)
  str.gsub(/\$\$[a-zA-Z0-9\-_]*/) do
    |c|
    if $recipe['global'][c[2,c.length]]
      c=$recipe['global'][c[2,c.length]]
    else
      printf("%s: variable %s not found in [global] array\n", path, c)
      exit(6)
    end
    return $` + c + var_parse($', path)
  end
end

# Context parsing
def context_parse(str)
  str.gsub(/^\w+/) do
    |context|
    unless $recipe['contexts']
      printf("Missing [contexts] array into recipe\n")
      exit(6)
    end
    if $recipe['contexts'][context]
      if $recipe['contexts'][context]['cmd']
        cmd=$recipe['contexts'][context]['cmd']
        args=$'.strip
      else
        printf("cmd not found in [contexts][%s] array\n", context)
        exit(6)
      end
    else
      printf("context %s not found in [contexts] array\n", context)
      exit(6)
    end
    if $recipe['contexts'][context]['escape']
      escape=$recipe['contexts'][context]['escape']
      args=args.gsub(/[#{escape}]/,"\\\\#{escape}")
    end
    cmd="chroot," + cmd.gsub(/%%/, args)
    return cmd

  end
end

### To write command into the clean script
### It has to be written in reverse order
def add_to_clean(cmd)
## Warning !! this solution dont scale well
## We charge the file into memory, so it wont probably work for large files.
  f = File.open($clean_script, "r+")
  lines = f.readlines
  f.close
  lines = [cmd+"\n"] + lines

  output = File.new($clean_script, "w")
  lines.each { |line| output.write line }
  output.close
end

### prompt user in case of command execution error (non-zero exit code)
def error_prompt()
  answer = String.new
  $stdout.flush
  answer=$stdin.gets
  $log.stdin_write(answer)
  while (not ["r\n","c\n","a\n","s\n"].include?(answer))
    print red("Press [r] to retry, [c] to continue with execution, [a] to abort execution, [s] to switch to shell: ")
    $stdout.flush
    answer=$stdin.gets
    $log.stdin_write(answer)
  end
  return answer[0,1]
end

### save an history file
def save_history
  open($histfile,'a') do |f|
    $history.each { |h| f.puts h }
  end
  $history = []
end

### starting cache
def start_cache(shell, cache_dir, polipo_bin_path)
  if not File.exist?(cache_dir)
    puts red("Error: the cache dir does not exist")
    sleep 10
  end
  puts blue("Starting cache in directory #{cache_dir}")
  sleep 1 #This has to be added for polipo to wait a bit. Otherwise it is not able to start.
  # FIXME
  ## there is not error handling here, I have to check if the status code of the execution of the polipo binary
  shell.execute("export http_proxy=http://localhost:8123",:stdout => $stdout, :stderr => $stderr)

  if @options[:path_to_cache].nil?
    shell.execute("#{polipo_bin_path} diskCacheRoot=\"#{cache_dir}\" idleTime=\"5\" chunkHighMark=\"425165824\" &",:stdout => $stdout, :stderr => $stderr)
    if shell.exit_status != 0
      puts red("Error executing polipo proxy")
      puts red("!! Warning: the cache will be incomple")
      sleep 2
    end

  else
    shell.execute("#{polipo_bin_path} diskCacheRoot=\"#{cache_dir}\" idleTime=\"5\" proxyOffline=\"true\"  chunkHighMark=\"425165824\" &",:stdout => $stdout, :stderr => $stderr)
  end
  shell.execute("export polipo_pid=$!")
end

### stoping cache
def stop_cache(shell,cache_dir)
  shell.execute("sleep 2")
  puts blue("Stoping cache in dir: #{cache_dir}")
  sleep 1
  shell.execute("kill -9 $polipo_pid",:stdout => $stdout, :stderr => $stderr)
end

## finish up with the cache
def cache_up(list_cmd)
  sleep 1
  puts green("Copying last files to create the cache")
  list_cmd.each{ |cmd|
    system(cmd)
  }
  ### need to change the steps files
end
### ERB interaction
def config_inject(template_name,output_file)
  ## global variables have to be put like this global['var']
  # global['distrib'] = "debian"
  # global['arch'] = "amd64"
  begin
    global = {}
    global = $recipe['global']
    template_path=$kameleon_templatedir+"/"+template_name
    template_file = File.open(template_path, 'r').read
    erb = ERB.new(template_file)
    File.open(output_file,'w+') { |file|
      file.write(erb.result(binding))
    }

    return "ERB done, configuration file: #{output_file} generated"
  rescue
    puts "Cleaning the environment"
    clean
  end
end

### orgmode history saving
def save_orgmode(script_step_hash)
  ## org mode file path
  org_mode_file=$recipe['global']['workdir']+"/building_flow.org"
  File.open(org_mode_file,'w') do |file|
    script_step_hash.each do |macrostep|
      macrostep_name = macrostep[0]
      file.puts "* #{macrostep_name}"
      macrostep[1].each do |microstep|
        microstep_name = microstep[0]
        file.puts "** #{microstep_name}"
        microstep[1].each do |command|
          file.puts command
        end
      end
    end
  end
end

### open prompt in the same enviromnent (shell) where the execution takes place
def start_shell(shell,histfile)
  puts green("Starting shell. Enter 'exit' to return to kameleon.")
#  n = 0
  unless File.file?(rcfile="#{ENV['HOME']}/.kameleon_rc")
    open(rcfile,'w') do |f|
      f.puts "source #{$recipe['global']['workdir_base']}/\$KAMELEON_TIMESTAMP/kameleon_env"
      f.puts "PS1='\\e[36;1mKAMELEON \\w # \\e[0m'"
    end
  end
  shell.execute("env |egrep -v '^PWD='|perl -pi -e 's/=/=\"/'|perl -pi -e 's/\$/\"/' >> #{$workdir}/kameleon_env")
  system("cd #{$workdir}; KAMELEON_TIMESTAMP=#{$timestamp} HISTFILE='#{histfile}' bash --rcfile #{rcfile}")

 # loop do
 #   print cyan("#{ n }:SHELL> ")
 #   command = $stdin.gets
 #   $log.stdin_"write(command)
 #   #command = Readline.readline(cyan("#{ n }:SHELL> "), true)
 #   if command =~ /^\s*\!*history\!*\s*$/
 #     open('shell.history','w'){|f| f.puts shell.history}
 #     next
 #   end
 #   #return if command =~ /^\s*(?:exit|quit)\s*$/io
 #   return if command =~ /^\s*\\q\s*$/io
 #
 #   shell.execute(command, :stdout => $stdout, :stderr => $stderr)
 #   n += 1
 # end
end

def append_to_env_file(line)
  open("#{$workdir}/kameleon_env",'a') { |f| f.puts line }
end

### Cleaning function
def clean()
  puts red("Running cleaning script...")
  #FIXME the clean script should be run on the specified context
  system("bash " + $clean_script)
  FileUtils.rm($clean_script)
end

# check for macrostep file (distro-specific or default)
def find_step(step, dist)

  ### Searching steps from cache if is activated
  if @options[:path_to_cache] and \
    File.file?(search_pathc= $recipe['global']['workdir'] +"/cache/#{step}/"+step+".yaml")
      return path = search_pathc
  end

  ### Searching in different path
  path=""
  searched_pathes=""
  pathes_to_search = []
  pathes_to_search += @options[:include_path]
  pathes_to_search += ["#{$current_dir}", "#{$kameleon_datadir}","#{$kameleon_bindir}"]

  if dist != ""
    pathes_to_search.each do |dir|
      if File.file?(search_path = dir + "/steps/" + dist + "/" + step + ".yaml")
        path=search_path
        break
      else
        searched_pathes=searched_pathes + " * " + search_path + "\n"
      end
    end
  else
    pathes_to_search.each do |dir|
      if File.file?(search_path1 = dir + "/steps/" + $recipe['global']['distrib'] + "/" + step + ".yaml")
        path=search_path1
        break
      elsif File.file?(search_path2 = dir + "/steps/default/" + step + ".yaml")
        path=search_path2
        break
      else
        searched_pathes=searched_pathes + " * " + search_path1 + "\n * " + search_path2 + "\n"
      end
    end
  end
  return path
end


### Load macrostep file
def load_macrostep_file(path)
  begin
    puts green("  | Loading " + path)
    macrostep_yaml = YAML.load(File.open(path))
    macrostep_yaml_cache =  YAML.load(File.open(path)) if @options[:cache]
    step_name =  macrostep_yaml.keys[0]
    file_name = File.basename( path , ".*" )
    if not step_name == file_name
      print red("ERROR: The macrostep inside name ("+ step_name +") MUST be the
same as the file name ("+ file_name +"). Check this file:\n" + path +"\n")
      exit(71)
    end
    return [macrostep_yaml, macrostep_yaml_cache]
  rescue
    print "Failed to open macrostep file. ", $!, "\n"
    exit(7)
  end
end

######################################
### parsing command line arguments ###
######################################

@options = {
  :include_path => []
}

option_parser = OptionParser.new do |opts|
  opts.banner = <<BANNER
Kameleon
* Description:
  Kameleon is an Open Source Bash automation tool. It aims at easily generate
  operating system images and export them in any raw or virtual disk format
* Usage:
  kameleon [-i data_path] recipe[.yaml]
* Options:
BANNER

  opts.on("-i", "--include [PATH]", "Include the given path in the kameleon search path") do |i|
    @options[:include_path].push(File.expand_path(i))
  end

  opts.on("-h","--help", "Show this message.") do
    puts opts
    exit(0)
  end

  opts.on("-o","--output [FILE]",String,"Where to save the image" ) do |o|
     @options[:output_path].push(File.expand_path(o))
  end

  opts.on("-c","--cache [PATH]","Generate cache for the image created") do |path|
    @options[:cache] = path || ""
  end

  opts.on("--from_cache [FILE]","Using specific cache to create the image") do |cache_file|
    @options[:path_to_cache] = cache_file
  end

  opts.on("--make_ckp [STEP]",String,"Checkpoint given step") do |step|
    @options[:make_ckp] = step
    if step.nil?
      puts "There is no argument for option --make_ckp"
      exit(0)
    end
  end

  opts.on("--restart_from_ckp [STEP]",String,"Restart the process form a checkpoint file and a given step") do |step|
    @options[:restart_from_ckp] = step
    if step.nil?
      puts "There is no argument for option --restart_from_ckp"
      exit(0)
    end
  end

end

if ARGV.length < 1
  puts option_parser
  exit(1)
end

option_parser.parse!



@options[:recipe] = ARGV[0]

######################
### initialization ###
######################

# define global vars
$current_dir=Dir.pwd
$kameleon_bindir=File.expand_path(File.dirname(__FILE__))
$kameleon_datadir=File.expand_path(File.dirname(__FILE__) + "/../share/kameleon")
$kameleon_templatedir = File.expand_path(File.dirname(__FILE__) + "/config")

version="1.2.8"
required_globals = ["distrib", "workdir_base"]
#DEAD CODE
#required_commands = ["chroot", "which", "cat", "echo"]

# check UID (need to be root in order to chacge root)
if Process.uid != 0
  puts "Kameleon: need to be root!"
  exit(3)
end

# open bash session in the background
begin
  bash = Session::Bash.new()
  bash_chroot = Session::Bash.new()

  # clean build env
  bash_chroot.execute("env -i bash", :stdout => $stdout, :stderr => $stderr)

  # load a default env
  # find the chroot env if install or not
  if File.exists? "#{$kameleon_bindir}/scripts/chroot_env"
    env_path = "#{$kameleon_bindir}/scripts/chroot_env"
  elsif File.exists? "#{$kameleon_datadir}/scripts/chroot_env"
    env_path = "#{$kameleon_datadir}/scripts/chroot_env"
  end
  bash_chroot.execute("source #{env_path}", :stdout => $stdout, :stderr => $stderr)
  if  bash_chroot.exit_status != 0
    print "Failed to load build environement variable."
    exit (31)
  end
rescue
  print "Failed to open bash session. ", $!, "\n"
  exit(3)
end


# load recipe
path=""
searched_pathes=""
pathes_to_search = []
pathes_to_search += @options[:include_path]
pathes_to_search += @options[:include_path].map { |p|  p + "/recipes" }
pathes_to_search += ["#{$current_dir}", "#{$current_dir}/recipes", "#{$kameleon_datadir}/recipes"]


pathes_to_search.each do |dir|
  if File.file?(search_path1 = dir + "/" + @options[:recipe])
    path=search_path1
    break
  elsif File.file?(search_path2 = dir + "/" + @options[:recipe] + ".yaml")
    path=search_path2
    break
  else
    searched_pathes=searched_pathes + " * " + search_path1 + "[.yaml]" + "\n"
  end
end
if path == ""
  printf("%s: could not find recipe in none of the following files : \n%s", @options[:recipe], searched_pathes)
  exit(2)
end
begin
  puts cyan("->") + green("| Loading " + path)
  $recipe = YAML.load(File.open(path))
rescue
  print "Failed to open recipe file. ", $!, "\n"
  exit(2)
end



# restarting from a checkpoint
if @options[:restart_from_ckp]
  ## verifying if the step exists
  if $recipe["steps"].index(@options[:restart_from_ckp]).nil?
    puts "Such a step does not exit in the recipe"
    exit(1)
  end
  $recipe["steps"].insert($recipe["steps"].index(@options[:restart_from_ckp])+1,'checkpoint_resume')
  while $recipe["steps"].shift!=@options[:restart_from_ckp]
  end
end

# inserting checkpoint if checkpint is enable
if @options[:make_ckp]
  # puts $recipe["steps"].index(@options[:make_ckp]).nil?
  # sleep 10
  if $recipe["steps"].index(@options[:make_ckp]).nil?
    puts "Such a step does not exit in the recipe"
    exit(1)
  end
  puts green("step to checkpoint: #{@options[:make_ckp]}")
  sleep 2
  $recipe["steps"].insert($recipe["steps"].index(@options[:make_ckp])+1,'checkpoint')
end


# check for required globals in the recipe file
required_globals.each do
  |var|
  if not $recipe['global'][var]
    printf("Recipe misses required variable: %s \n", var)
    exit(4)
  end
end

### Create workdir and chroot directory.
# Dir structure should look like this:
# $workdir_base/<timestamp>/chroot
# Example: /var/tmp/kameleon/2009-07-10-18-55-34/chroot
# We also define two global vars here: $workdir and $chroot
$timestamp=Time.now.strftime("%Y-%m-%d-%H-%M-%S")
start_time=Time.now.to_i
$recipe['global']['recipedir'] = File.basename(path, ".yaml")
$recipe['global']['workdir'] = $workdir = $recipe['global']['workdir_base']+"/"+$timestamp
$recipe['global']['chroot'] = $chroot = $workdir + "/chroot"
$recipe['global']['bindir'] = $current_dir
$recipe['global']['clean'] = $clean_script

## This is a data directory to make reference in the recipes,
## It aims at working with the option --include in kameleon.
if @options[:include_path] then
  @options[:include_path].each do |in_path|
    if File.exist?(in_path+"/data/")
      $recipe['global']['data_dir'] = in_path+"/data/"
    else
      puts red("!! Warning the data directory is not defined")
    end
  end
end

begin
  FileUtils.mkdir_p($chroot) ### need to change the user to kameleon here
rescue
  print "Failed to create working directory. ", $!, "\n"
  exit(5)
end

# open logfile
class KLogger < File
  def initialize(filename)
    super(filename, 'w')
  end
  def open(filename)
    super(filename, 'w')
  end
  def write(str, stdout="yes")
    if stdout=="yes"
      STDOUT.write(str)
      STDOUT.flush()
    end
    super(str)
    flush()
  end
  def <<(str)
     write(str)
#    STDOUT.<<(str)
#    super(str)
  end
  def stdin_write(str)
     write(str,"no")
  end
end

$log=KLogger.new($workdir + ".log")
$stdout=$log
$stderr=$log

## Creating the cache directory and checking the availability of polipo binary if caching is enabled
if @options[:cache]
  # Checking for polipo bin in the path
  polipo_bin_path = `which polipo`.delete("\n")
  ## Checking for the existing of polipo binary
  # polipo_bin_path=$current_dir+"/redist/bin/polipo" if not polipo_bin_path
  if not File.exist?(polipo_bin_path)
    puts red("Error: Polipo binary not found")
    puts red("Unable to start cache")
    exit(1)
  end
  ## puting cleaning command for polipo
  add_to_clean("killall polipo")
  ## Checking if polipo is running
  bash.execute("ps cax | grep polipo > /dev/null")
  if bash.exit_status == 0
    puts red("Polipo is running, exiting kameleon")
    exit(1)
  end
  cache_dir = @options[:cache].empty? ? $recipe['global']['workdir']+"/cache/" : @options[:cache]+"/cache/"
  FileUtils.mkdir_p(cache_dir)
  ## When creating the cache it is important to save the cache directory as a global variable
  ## to generate actions to cache commands after
  $recipe['global']['cache_dir'] = cache_dir
  ### list of command to be executed so as to complete the cache.
  cache_cmd=[]
end

## if from cache is activated, decompress the tar cache file into the workdir directory
if @options[:path_to_cache]
  puts green("Untaring cache file into the workdir directory")
  bash.execute("tar -xvf #{@options[:path_to_cache]} -C #{$recipe['global']['workdir']}", :stdout => $stdout, :stderr => $stderr)
  ## to keep the cache direcory in the global variables and have acces form a recipe
  $recipe['global']['cache_dir'] = $recipe['global']['workdir']+"/cache/"
  ## so from the recipe I can do something like:
  ## $$cache/step/archilinux.sh --arch i386
end
#Readline.output=log

###################
### Preparation ###
###################

# this hash will be used to store pieces of the bash script
script = OrderedHash.new()

# parse recipe, load macrostep files, load microsteps, convert command definitions
# into bash commands. All missing pieces should be detected and reported during
# this phase and before the actual system installation and image building (execution)
$recipe['steps'].each do
  |macrostep|

  # get the name of the step;
  # test if we're dealing with the list of microsteps
  if macrostep.kind_of?(String)
    step = macrostep
  else
    step = macrostep.keys[0]
  end

  # check for a file imported from another distrib
  if step =~ /(.+)\/(.+)/
    step=$2
    dist=$1
  else
    dist=""
  end

  # create a structure that looks something like this:
  # script["oar_init"]["start_appliance_mysql"][0] = \
  # = "chroot /path/to/chroot/dir /etc/init.d/mysql start"
  if script[step].nil?
    script[step] = OrderedHash.new()
  else
    puts "Error: '#{step}' defined twice! Exiting as the first occurence is going to"
    puts "not be executed at all and this is probably not what you want."
    exit(11)
  end

  path = find_step( step, dist )

  if path == ""
    printf("%s: macrostep file is missing: \n%s", step, searched_pathes)
    exit(6)
  elsif path.start_with?( $recipe['global']['workdir'] +"/cache/" )
    puts green("  | Loading from cache !!!")
  end

  macrostep_yaml, macrostep_yaml_cache = load_macrostep_file( path )

  # add includes steps
  macrostep_yaml[step].each_index do |key|
    microstep=macrostep_yaml[step][key]
    if microstep.keys[0] == "include"
      # load macrostep file
      include_step = microstep.values[0][0]
      begin
        include_path = find_step( include_step , dist )
        #FIXME: need to handle cache (Not sure macrostep_yaml_cache is needed)
        macrostep_include_yaml, _ = load_macrostep_file( include_path )
        #TODO make it work when user select only a list of microstep
        ind = 1
        macrostep_include_yaml.values[0].each do |microstep_include|
          macrostep_yaml[step].insert(key+ind, microstep_include)
          ind+=1
        end
        macrostep_yaml[step].delete_at(key)
      rescue
        print "Failed to open included macrostep file. ", $!, "\n"
        exit(7)
      end
    end
  end


  #
  ### saving steps if cache is activated
  if @options[:cache] and not @options[:path_to_cache]
    step_name=File.basename(path)
    FileUtils.mkdir(cache_dir+step)
    FileUtils.mkdir(cache_dir+step+"/data/") ## to save scrips used during the creation of the image
    FileUtils.cp_r(File.dirname(path)+"/data/",cache_dir+"/#{step}/") if File.directory?(File.dirname(path)+"/data/")
    ## copying the data directory for the step into the cache
    #FIXME: This method has an issue, it will copy several times the data directory
    # if there exits several steps in the same directory
    ## E.g.,
    ## oar_config, oar_system_config, oar_debian_install are under the same directory
    FileUtils.cp(path,cache_dir+"/#{step}/"+step_name)
    # File.open($recipe['global']['workdir']}+"/cache/"+step_name) do |step_file|
    #   YAML.dump(macrostep_yaml,step_file)
    # end
  end

  # Define the variable stepdir before parsing the yaml file.
  $recipe['global']['stepdir'] = File.dirname(path)

  # traverse macrosteps->microsteps->commands structure, parse commands;
  # test if we're dealing with the list of microsteps
  if macrostep.kind_of?(String)
    macrostep_yaml[step].each_with_index do |microstep,ind_micro|
      script[step][microstep.keys[0]] = Array.new()
      microstep.values[0].each_with_index do
        |command,ind_cmd|
        ## now we possibly return an array from cmd_parse
        ## which enables to represent a kameleon command
        ## by various bash commands.
        cmd_string = ""
        temp_result = cmd_parse(command,step+"->"+microstep.keys[0])
        if temp_result.kind_of?(Array)
          temp_result.each do |result_ind|
            cmd_string = var_parse(result_ind,path)
            script[step][microstep.keys[0]].push(cmd_string)
          end
        else
          cmd_string=var_parse(temp_result,path)
          script[step][microstep.keys[0]].push(cmd_string)
        end

        ## we test here if we must cache the command executed.
        if @options[:cache]
          action,old_exec,new_exec = cmd_cache?(cmd_string.split(";")[1],step)
          if not action.nil?
            puts "Printing actions #{var_parse(action,path)}"
            cache_cmd.push(var_parse(action,path))
            k = macrostep_yaml_cache[step][ind_micro].values[0][ind_cmd].values[0].split(" ")
            k.shift
#            macrostep_yaml_cache[step][ind_micro].values[0][ind_cmd].values[0][old_exec]=new_exec
            macrostep_yaml_cache[step][ind_micro].values[0][ind_cmd].values[0]="#{new_exec} #{k.join(" ")}"
          end
        end
        cmd_string=cmd_string.gsub(/['()]/,"\\\\\0")
        append_to_env_file("alias #{step}_#{microstep.keys[0]}='#{cmd_string}'")
      end
    end
  else
    if macrostep.values[0].nil?
      puts "Error in recipe: '#{step}' microsteps list is empty!"
      exit 1
    end
    macrostep.values[0].each do
      |microstep|
      script[step][microstep] = Array.new()

      found = nil
      counter = 0
      macrostep_yaml[step].each do
        |microstep_yaml|
        if microstep_yaml.keys[0] == microstep
          found=counter
        end
        counter+=1
      end

      if not found
        printf("Microstep %s required by %s missing in %s.\n", microstep, @options[:recipe], path)
        exit(8)
      end

      macrostep_yaml[step][found].values[0].each do
        |command|
        cmd_string=var_parse(cmd_parse(command,step+"->"+microstep),path)
        script[step][microstep].push(cmd_string)
        cmd_string=cmd_string.gsub(/['()]/,"\\\\\0")
        append_to_env_file("alias #{step}_#{microstep}='#{cmd_string}'")
      end

    end
  end
  ### we have to save the macrostep
  if @options[:cache]
    step_name=File.basename(path)
    File.open(cache_dir+"/#{step}/"+step_name,'w') do |step_file|
      step_file.write(macrostep_yaml_cache.to_yaml)
    end
  end
end

#################
### Execution ###
#################

puts blue("\n ### ") + green("Welcome to Kameleon " + version) + blue(" ###\n")

trapped=false
trap("INT") {
  if not trapped
    trapped=true
    begin
      bash.close!()
    rescue
    end
    puts red("Interrupted.")
    sleep(1)
    clean()
    puts("Exiting kameleon.")
    save_history
    exit
  end
}

# creating the cache directory
# traverse macrostep->microstep->command structure
script.each do
  |macrostep|
  ## including temporally caching for each step
  macrostep_name=macrostep[0]
  if @options[:cache] then
    cache_dir_step = cache_dir + macrostep_name
    start_cache(bash_chroot, cache_dir_step, polipo_bin_path)
  elsif @options[:path_to_cache]
    cache_dir_step = $recipe['global']['workdir']+"/cache/" + macrostep_name
    start_cache(bash_chroot, cache_dir_step, polipo_bin_path)
  end

  macrostep[1].each do
    |microstep|
    microstep_name=microstep[0]
    puts cyan("->") + green("| Executing " + macrostep_name) + cyan("->") + green(microstep_name)
    microstep[1].each do
      |command|
      begin
        next_cmd=0
        while next_cmd!=1
          # check for special commands
          if command[0,14] == "KML-breakpoint"
            puts green("  |-> Breakpoint: " + command[15,command.length])
            # open interactive shell instead of executing a command
            save_history
            start_shell(bash,$histfile)
          elsif command[0,10] == "ERB-config"
            puts green("  |-> Calling ERB config")
            template = command.split(",")[1]
            output_file=command.split(",")[2]
            puts green(" |-> "+ config_inject(template,output_file))
          elsif command[0,6] == "chroot"
            cmd_chroot = command.split(",")[1]
            puts green("  |-> " + cmd_chroot)
            bash_chroot.execute(cmd_chroot, :stdout => $stdout, :stderr => $stderr)
          elsif command[0,13] == "Clean-command"
            puts green(" |-> Clean command")
            clean_cmd = command.split(",")[1]
            add_to_clean(clean_cmd)
          else
            #This is a normal command
            puts green("  |-> " + command)
            # execute the command in the background bash session, connecting
            # it's stdout and stderr to kameleon's stdout and stderr
            bash.execute(command, :stdout => $stdout, :stderr => $stderr)
            $history << command
          end
          # check exit status, and stop execution on non-zero exit code
          if (bash.exit_status + bash_chroot.exit_status !=0) && (command[0,14] != "KML-breakpoint") #&& (bash_chroot.exit_status !=0)
            answer=String.new
            puts red("Error executing command.")
            puts "Launch context exit code: %s\nBuild context exit code: %s\nHistory: %s", bash.exit_status, bash_chroot.exit_status
            pp(bash)
            print red("Press [r] to retry, [c] to continue with execution, [a] to abort execution,\
                      [s] to switch to launch context shell, [b] to switch to build context shell : ")
            # offer three options: continue, abort, switch to shell (manually fix the error and then continue)
            while not ["c","r"].include?(answer=error_prompt)
              if answer=="s"
                save_history
                start_shell(bash,$histfile)
                puts green("Getting back to Kameleon ...")
                print green("Press [r] to retry, [c] to continue with execution, [a] to abort execution, [s] to switch to shell: ")
              elsif answer=="a"
                puts red("Aborting execution ...")
                begin
		  bash.close!()
		rescue
		end
		sleep(1)
		clean()
                puts red("You should clean workdir: " + $workdir)
                exit(10)
              end
            end
            if answer=="c"
              ## resetting the exit status
              bash.execute("true")
              bash_chroot.execute("true")
              next_cmd=1
            end
            #TODO retry should reload the current step if modified
          else
            next_cmd=1
          end
        end
      #rescue
      #  printf "%s->%s: Failed to execute command: %s\nException: ", macrostep_name, microstep_name, command
      #  print $!, "\n"
      #  exit(3)
      end
    end
  end
  stop_cache(bash_chroot, cache_dir_step) if @options[:cache] || @options[:path_to_cache]
end
save_history
## Finishing to generate cache, put it additional files
if @options[:cache]
  cache_up(cache_cmd)
  ## Creating a tar file with the cache contents
  cache_updir=File.dirname(cache_dir) ## the upper dir for cache
  bash.execute("cd #{cache_updir} ; tar -cf cache-#{$timestamp}.tar cache/", :stdout => $stdout, :stderr => $stderr)
end
begin
  bash.close!()
  bash_chroot.close!()
rescue
end
sleep(1)
clean

### Printing time spent on the whole process
total_time = Time.now.to_i - start_time
puts green("Total time spend on the process: #{total_time} secs")

puts green("Saving everything as org mode format file")
save_orgmode(script)

=begin

=DESCRIPTION

=USAGE

=SEE ALSO

=end
