build_appliance:

  - create_raw_image:
    - check_cmd: sfdisk
    # FIXME: take the size in args (maybe use fallocate instaead)
    - exec_appliance: |
        dd if=/dev/zero of=$$workdir/image.raw bs=1M count=1 seek=5000 # seek=3000
        echo -e "1,574,83,*\n575,,82" | sfdisk $$workdir/image.raw

  - attach_kpartx_device:
    - check_cmd: kpartx
    - exec_appliance: |
        # activate loop device
        modprobe loop
        # create loop device and guess partitions
        export LO_DEVICE=`kpartx -a -v $$workdir/image.raw \
          | head -n 1 | cut -d ' ' -f 8`
        export LO_DEVICE_PARTBASE=/dev/mapper/`basename ${LO_DEVICE}`
        # mkfs
        mkfs.$$output_environment_file_system_type ${LO_DEVICE_PARTBASE}p1
        export SWAP_UUID=`mkswap ${LO_DEVICE_PARTBASE}p2 \
          | egrep -o "UUID=(.*)" | cut -d= -f2`
        # mount_image
        mkdir $$workdir/mnt
        mount ${LO_DEVICE_PARTBASE}p1 $$workdir/mnt
    - exec_on_clean: |
        echo "Cleaning loop device $LO_DEVICE"
        umount $$workdir/mnt
        kpartx -d $LO_DEVICE
        losetup -d $LO_DEVICE
        rm -rf $$workdir/mnt

  - copy_system_tree:
    - exec_appliance: |
        rsync -a --exclude "/proc/" --exclude "/sys/" $$chroot/* $$workdir/mnt
        mkdir $$workdir/mnt/proc
        mkdir $$workdir/mnt/sys

  - get_kernel_initrd:
    - exec_appliance: |
        export kernel=`basename $$chroot/boot/vmlinuz*`
        export initrd=`basename $$chroot/boot/init*`

  - install_extlinux:
    # FIXME: Extlinux should be install by in the chroot to get
    # the same version as the generated system using:
    # extlinux -v |& cut -d' ' -f2 | cut -d'.' -f1
    - check_cmd: extlinux
    - exec_appliance: | 
        mkdir -p $$workdir/mnt/boot
        # install extlinux
        extlinux --install $$workdir/mnt/boot/
        # install bootloader
        # TODO if extlinux version is >= 6 use
        # /usr/lib/bios/syslinux/mbr.bin 
        dd if=/usr/lib/syslinux/mbr.bin conv=notrunc bs=440 count=1 of=$LO_DEVICE
        export UIID=`blkid -s UUID -o value ${LO_DEVICE_PARTBASE}p1`
    - append_file:
      - /etc/fstab
      - UIID=$UIID   /   $$output_environment_file_system_type defaults  0  0
    - append_file:
      - /boot/extlinux.conf 
      - |
        DEFAULT kameleon
        LABEL   kameleon
        SAY     Booting appliance
        LINUX   /boot/$kernel
        APPEND  root=/dev/disk/by-uuid/$UIID
        INITRD  /boot/$initrd

    ## FIXME the grub install needs to be debug

    #- grub_197_workaround:
    #  - exec_appliance: mkdir -p $$workdir/mnt/boot/grub
    #  - write_file: 
    #    - /boot/grub/device.map
    #    - (hd0,1) ${LO_DEVICE_PARTBASE}p1

    #- install_grub:
    #  - exec_appliance: mkdir -p $$workdir/mnt/boot/grub
    #  - append_file:
    #    - /boot/grub/device.map
    #    - |
    #      (hd0) $LO_DEVICE
    #      (hd0) /dev/hda
    #  - exec_appliance: |
    #      grub-install --root-directory=$$workdir/mnt --modules="biosdisk part_msdos" $LO_DEVICE
    #      export kernel=`ls $$workdir/mnt/boot/vmlinuz* | grep -o "2.6.*"`
    #      export hda1=`grub-probe -t fs_uuid -d ${LO_DEVICE_PARTBASE}p1`
    #      export INITRD=`find ./boot -name "initrd*$kernel*"|head -1|tail -c +2`
    #  - append_file:
    #    - /etc/fstab 
    #    - |
    #      UUID=$hda1 / $$output_environment_file_system_type  errors=remount-ro 0 1
    #      UUID=$SWAP_UUID   none  swap  sw  0   0
    #  - write_file: 
    #    - /boot/grub/grub.cfg
    #    - |
    #      set default=0
    #      set timeout=3
    #      set root='(hd0,1)'
    #      menuentry "$kernel" {
    #        linux /boot/vmlinuz-$kernel root=UUID=$hda1 ro
    #        initrd $INITRD
    #      }

