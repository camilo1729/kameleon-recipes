# Build Appliance

- export_tgz:
  - pipe:
    - exec_in: tar -zcf - -C / . --numeric-owner --one-file-system --exclude=tmp/*
    - exec_out: cat > ./$$kameleon_recipe_name.tar.gz
  - exec_out: echo "Saved tar.gz appliance to $(pwd)/$$kameleon_recipe_name.tar.gz"

- create_raw_image:
  - check_cmd_out: qemu-img
  - exec_out: qemu-img create -f raw $$kameleon_recipe_name.raw $$image_size

- attach_nbd_device:
  - check_cmd_out: qemu-nbd
  - exec_out: mkdir -p $$mountdir
  - exec_out: echo Looking for nbd device...
  - exec_out: modprobe nbd max_part=16 || fail failed to load nbd module into kernel
  - exec_out: |
      for i in /dev/nbd*
      do
        echo "Trying to connect $$kameleon_recipe_name.raw to nbd device $i"
        qemu-nbd -c $i $$kameleon_recipe_name.raw && export DISK=$i && break || true
      done
      test ! "$DISK" == "" ||  fail no nbd device available
  - exec_out: echo "$DISK" > .nbd_disk_path
  - exec_out: echo "Connected $$kameleon_recipe_name.raw to $DISK"
  - on_export_clean:
    - exec_out: sync
    - exec_out: test ! -f .nbd_disk_path || qemu-nbd -d $(cat .nbd_disk_path)
    - exec_out: rm -f .nbd_disk_path

- partition_disk:
  - check_cmd_out: sfdisk
  - exec_out: |
      echo "Partitioning $DISK..."
      sfdisk ${DISK} -q -D -uM <<< '
      ,200,83,*
      ;
      ' || fail cannot partition $$kameleon_recipe_name.raw
  - exec_out: |
      echo Creating boot partition...
      mkfs.$$filesystem_type -q ${DISK}p1 || fail cannot create /boot ext4
  - exec_out: |
      echo Creating root partition...
      mkfs.$$filesystem_type -q ${DISK}p2 || fail cannot create / ext4

- mount_mountdir:
  - exec_out:  "echo Mounting root partition... ;  mount ${DISK}p2 $$mountdir || fail cannot mount /"
  - on_export_clean:
    - exec_out: "echo umounting $$mountdir... ; mountpoint -q $$mountdir && umount -f -l $$mountdir || true"
  - exec_out: mkdir -p $$mountdir/boot
  - exec_out:  "echo Mounting boot partition... ;  mount ${DISK}p1 $$mountdir/boot || fail cannot mount /boot"
  - on_export_clean:
    - exec_out: "echo umounting $$mountdir/boot... ; mountpoint -q $$mountdir/boot && umount -f -l $$mountdir/boot || true"

- copy_tree_rootfs:
  - exec_out:  tar zxf $$kameleon_recipe_name.tar.gz -C "$$mountdir"

- generate_fstab:
  - write_out:
    - $$mountdir/etc/fstab
    - |
      # /etc/fstab: static file system information.
      #
      # Use 'blkid' to print the universally unique identifier for a
      # device; this may be used with UUID= as a more robust way to name devices
      # that works even if disks are added and removed. See fstab(5).
      #
      # <file system> <mount point>   <type>  <options>       <dump>  <pass>
      UUID=`blkid -s UUID -o value ${DISK}p2` /               $$filesystem_type    errors=remount-ro  0       1
      UUID=`blkid -s UUID -o value ${DISK}p1` /boot           $$filesystem_type    sync               0       2
      /dev/sr0        /media/cdrom0   udf,iso9660 user,noauto     0       0



- get_kernel_initrd:
  # FIXME: not sure it's working for all distro
  - exec_out: |
      export kernel=`basename mnt/boot/vmlinuz*`
      export initrd=`basename mnt/boot/init*`

- install_extlinux:
  # FIXME: Extlinux should be install using the 'exec' command to get
  # the same version as the generated system
  # extlinux -v |& cut -d' ' -f2 | cut -d'.' -f1
  - check_cmd_out: extlinux
  - exec_out: | 
      mkdir -p mnt/boot
      # install extlinux
      extlinux --install mnt/boot
      # install bootloader
      # TODO if extlinux version is >= 6 use
      # /usr/lib/bios/syslinux/mbr.bin instead of /usr/lib/syslinux/mbr.bin 
      dd if=/usr/lib/syslinux/mbr.bin conv=notrunc bs=440 count=1 of=${DISK}

  - write_out:
    - mnt/boot/extlinux.conf
    - |
      default linux
      timeout 1
      
      label linux
      kernel $kernel
      append initrd=$initrd root=UUID=`blkid -s UUID -o value ${DISK}p2` ro
