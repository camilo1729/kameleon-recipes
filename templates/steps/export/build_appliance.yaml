# Build Appliance

- create_raw_image:
  - check_cmd: fallocate
  # FIXME: the size in args must be greater then the appliance
  - exec_out: |
      echo "Appliance size: $(du -bch $$rootfs | awk 'END {print $1}')"
      fallocate -l $$img_size image.raw
      fdisk image.raw <<< '
      o
      n
      p
      1
      
      
      a
      w
      '

- attach_kpartx_device:
  - check_cmd: kpartx
  - exec_out: |
      # activate loop device
      modprobe loop
      # create loop device and guess partitions
      export LO_DEVICE=`kpartx -a -v image.raw \
        | head -n 1 | cut -d ' ' -f 8`
      export LO_DEVICE_PARTBASE=/dev/mapper/`basename ${LO_DEVICE}`
      # mkfs
      mkfs.$$output_environment_file_system_type ${LO_DEVICE_PARTBASE}p1
      
      # not needed if the swap is a file
      #export SWAP_UUID=`mkswap ${LO_DEVICE_PARTBASE}p2 \
      #  | egrep -o "UUID=(.*)" | cut -d= -f2`
      
      # mount_image
      mkdir mnt
      mount ${LO_DEVICE_PARTBASE}p1 mnt
  - on_step_clean:
    - exec_out: |
        umount mnt
        kpartx -d $LO_DEVICE
        losetup -d $LO_DEVICE
        rm -rf mnt

- copy_system_tree:
  - exec_out: |
      rsync -aAXv $$rootfs/* mnt \
      --exclude={/dev/*,/proc/*,/sys/*,/tmp/*,/run/*,/mnt/*,/media/*,/lost+found}

- get_kernel_initrd:
  # FIXME: not sure it's working for all distro
  - exec_out: |
      export kernel=`basename mnt/boot/vmlinuz*`
      export initrd=`basename mnt/boot/init*`

- install_extlinux:
  # FIXME: Extlinux should be install using the 'exec' command to get
  # the same version as the generated system
  # extlinux -v |& cut -d' ' -f2 | cut -d'.' -f1
  - check_cmd: extlinux
  - exec_out: | 
      mkdir -p mnt/boot
      # install extlinux
      extlinux --install mnt/boot/
      # install bootloader
      # TODO if extlinux version is >= 6 use
      # /usr/lib/bios/syslinux/mbr.bin instead of /usr/lib/syslinux/mbr.bin 
      dd if=/usr/lib/syslinux/bios/mbr.bin conv=notrunc bs=440 count=1 of=$LO_DEVICE
      export UIID=`blkid -s UUID -o value ${LO_DEVICE_PARTBASE}p1`
  - exec_out: |
      cat > mnt/etc/fstab <<< "
      UIID=$UIID   /   $$output_environment_file_system_type defaults  0  0
      "
  - exec_out: |
      cat > mnt/boot/extlinux.conf <<< "
      DEFAULT kameleon
      LABEL   kameleon
      SAY     Booting appliance
      LINUX   /boot/$kernel
      APPEND  root=/dev/disk/by-uuid/$UIID
      INITRD  /boot/$initrd
      "

  ## FIXME the grub install needs to be debug

  #- grub_197_workaround:
  #  - exec_appliance: mkdir -p $$workdir/mnt/boot/grub
  #  - write_file: 
  #    - /boot/grub/device.map
  #    - (hd0,1) ${LO_DEVICE_PARTBASE}p1

  #- install_grub:
  #  - exec_appliance: mkdir -p $$workdir/mnt/boot/grub
  #  - append_file:
  #    - /boot/grub/device.map
  #    - |
  #      (hd0) $LO_DEVICE
  #      (hd0) /dev/hda
  #  - exec_appliance: |
  #      grub-install --root-directory=$$workdir/mnt --modules="biosdisk part_msdos" $LO_DEVICE
  #      export kernel=`ls $$workdir/mnt/boot/vmlinuz* | grep -o "2.6.*"`
  #      export hda1=`grub-probe -t fs_uuid -d ${LO_DEVICE_PARTBASE}p1`
  #      export INITRD=`find ./boot -name "initrd*$kernel*"|head -1|tail -c +2`
  #  - append_file:
  #    - /etc/fstab 
  #    - |
  #      UUID=$hda1 / $$output_environment_file_system_type  errors=remount-ro 0 1
  #      UUID=$SWAP_UUID   none  swap  sw  0   0
  #  - write_file: 
  #    - /boot/grub/grub.cfg
  #    - |
  #      set default=0
  #      set timeout=3
  #      set root='(hd0,1)'
  #      menuentry "$kernel" {
  #        linux /boot/vmlinuz-$kernel root=UUID=$hda1 ro
  #        initrd $INITRD
  #      }

